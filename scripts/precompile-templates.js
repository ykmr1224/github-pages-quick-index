#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const Handlebars = require('handlebars')

/**
 * Precompiles Handlebars templates into TypeScript modules
 * This creates self-contained template functions that work in any environment
 */

const TEMPLATES_DIR = path.join(__dirname, '..', 'src', 'templates')
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'compiled-templates')

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true })
}

// Find all .html files in templates directory
const templateFiles = fs.readdirSync(TEMPLATES_DIR)
  .filter(file => file.endsWith('.html'))

console.log(`üîß Precompiling ${templateFiles.length} template(s)...`)

templateFiles.forEach(templateFile => {
  const templateName = path.basename(templateFile, '.html')
  const templatePath = path.join(TEMPLATES_DIR, templateFile)
  const outputPath = path.join(OUTPUT_DIR, `${templateName}-template.ts`)
  
  try {
    // Read template content
    const templateContent = fs.readFileSync(templatePath, 'utf-8')
    
    // Precompile the template
    const compiled = Handlebars.precompile(templateContent)
    
    // Create TypeScript module with precompiled template
    const tsModule = `// Auto-generated from ${templateFile}
// Do not edit this file directly - edit the template file instead
/* eslint-disable */
// @ts-nocheck

/**
 * Precompiled Handlebars template for ${templateName}
 * This template function works without requiring Handlebars at runtime
 */

// Minimal Handlebars runtime for precompiled templates
const HandlebarsRuntime = {
  template: function(spec: any) {
    return function(context: any) {
      return spec.main(HandlebarsRuntime, context, {}, {}, {});
    };
  },
  hooks: {
    helperMissing: function() {
      return '';
    }
  },
  lookupProperty: function(parent: any, propertyName: string) {
    if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
      return parent[propertyName];
    }
    return undefined;
  },
  escapeExpression: function(string: any) {
    if (typeof string !== 'string') {
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }
      string = '' + string;
    }
    return string.replace(/[&<>"']/g, function(match: string) {
      const escape: { [key: string]: string } = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      };
      return escape[match];
    });
  }
};

// Precompiled template function
const templateSpec: any = ${compiled};

// Export the template function
export const ${templateName}Template = HandlebarsRuntime.template(templateSpec);
`
    
    // Write compiled template
    fs.writeFileSync(outputPath, tsModule)
    console.log(`‚úÖ Precompiled ${templateFile} ‚Üí ${templateName}.ts`)
    
  } catch (error) {
    console.error(`‚ùå Error precompiling ${templateFile}:`, error.message)
    process.exit(1)
  }
})

// Create index file to export all templates
const indexContent = templateFiles
  .map(file => {
    const templateName = path.basename(file, '.html')
    const fileName = path.basename(file, '.html')
    // Avoid circular import by using different file names
    return `export { ${templateName}Template } from './${fileName}-template';`
  })
  .join('\n') + '\n'

fs.writeFileSync(path.join(OUTPUT_DIR, 'index.ts'), indexContent)

console.log(`üéâ Template precompilation complete!`)
console.log(`üìÅ Generated ${templateFiles.length} TypeScript modules in src/compiled-templates/`)
